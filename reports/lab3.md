# 实验报告
## 功能实现部分
定义一个新的系统调用 sys_spawn，其参数为目标程序的路径 path，返回新建子进程的进程ID或者-1表示失败。
在内核中注册 sys_spawn 系统调用，分配一个唯一的系统调用号，例如400。
在用户空间编写一个函数 spawn，通过系统调用 syscall 发起 sys_spawn 调用，传递目标程序路径作为参数，并处理返回结果。
在内核中实现 sys_spawn 系统调用的处理函数，根据传入的路径参数，创建一个新的进程控制块（PCB），并加载目标程序到新进程的地址空间中。
将新进程加入就绪队列，使其能够被调度执行。若创建成功，则返回新进程的进程ID，否则返回-1表示失败。
## 问答作业
### fork + exec 的一个比较大的问题是 fork 之后的内存页/文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？
改进策略是使用 Copy-On-Write (COW) 技术，它延迟了资源的复制过程，直到有写操作发生时才复制。这样可以减少不必要的资源浪费，因为只有在实际需要修改时才会复制资源，而在大多数情况下，子进程只是读取父进程的内存页或文件，因此可以共享这些资源，从而提高效率和节省内存。
### [选做，不占分] 其实使用了题 (1) 的策略之后，fork + exec 所带来的无效资源的问题已经基本被解决了，但是今年来 fork 还是在被不断的批判，那么到底是什么正在”杀死”fork？可以参考 论文 。
资源消耗：在调用 fork() 后，父进程的地址空间被完全复制到子进程中，这意味着在内存中需要分配两倍于父进程大小的空间。对于大型进程来说，这会带来显著的资源消耗，特别是在内存有限的情况下。
性能开销：fork() 调用涉及复制整个进程的地址空间，这会导致较大的性能开销，特别是在需要频繁创建子进程的情况下。复制大量内存可能需要很长时间，这会降低程序的整体性能。
写时复制（Copy-on-Write）机制的局限性：虽然现代操作系统中使用了写时复制技术来减少内存复制的开销，但在某些情况下，仍然需要立即复制整个地址空间，导致性能下降。
并发编程困难：在使用 fork() 创建子进程后，父子进程之间的通信和同步可能会变得复杂。共享的资源需要谨慎管理，以避免竞态条件和死锁等并发问题。
安全性：在某些情况下，fork() 可能会导致安全漏洞，特别是在多线程程序中，由于共享的资源被复制到子进程中，可能会导致意外的数据泄露或破坏。
### 请阅读下列代码，并分析程序的输出，假定不发生运行错误，不考虑行缓冲：
```
int main(){
int val = 2;
printf("%d", 0);
int pid = fork();
if (pid == 0) {
val++;
printf("%d", val);
} else {
val--;
printf("%d", val);
wait(NULL);
}
val++;
printf("%d", val);
return 0;
}
```
如果 fork() 之后主程序先运行，则结果如何？如果 fork() 之后 child 先运行，则结果如何？
## 请阅读下列代码，分析程序的输出 A 的数量：( 已知 && 的优先级比 || 高)
```
int main() {
fork() && fork() && fork() || fork() && fork() || fork() && fork();
printf("A");
return 0;
}
```
[选做，不占分] 更进一步，如果给出一个 && || 的序列，如何设计一个程序来得到答案？
输出 A 的数量为 6
假设&& 和 || 运算符组成的逻辑表达式：(A && B) || (C && D && E) || (F && G)
```
#include <stdio.h>

int evaluate_expression(int A, int B, int C, int D, int E, int F, int G) {
    int result = (A && B) || (C && D && E) || (F && G);
    return result;
}

int main() {
    // 设置变量的值，代表表达式中的各个变量的真假值
    int A = 1, B = 0, C = 1, D = 0, E = 1, F = 0, G = 1;

    // 计算表达式的结果
    int result = evaluate_expression(A, B, C, D, E, F, G);

    // 输出结果
    if (result)
        printf("Expression is true\n");
    else
        printf("Expression is false\n");

    return 0;
}
```
首先定义了一个函数 evaluate_expression，该函数接受表达式中各个变量的真假值作为参数，并计算表达式的结果。然后在 main 函数中，我们设置了这些变量的值，然后调用 evaluate_expression 函数计算表达式的结果，并输出结果
## 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容： 1.我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。 2.我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。